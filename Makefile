# Makefile
#
# This file is based on CMU's 18-447 Spring 2019 Makefile. That class
# uses the RISC-V ISA; this version has been modified to use x86.
#

################################################################################
# User Controlled Parameters
################################################################################

# The output directories for simulation and synthesis files and results
OUTPUT_BASE_DIR = output
SIM_OUTPUT = $(OUTPUT_BASE_DIR)/simulation
OUTPUT = $(SIM_OUTPUT)

# Top unit of the design
TOP_UNIT = ia32

################################################################################
# General Targets and Variables
################################################################################

# Set the shell to bash for when the Makefile runs shell commands. Enable the
# pipefail option, so if any command in a pipe fails, the whole thing fails.
# This is necessary for when a failing command is piped to `tee`.
SHELL = /bin/bash -o pipefail

# Set the number of threads to use for parallel compilation (2 * cores)
CORES = $(shell getconf _NPROCESSORS_ONLN)
THREADS = $(shell echo $$((2 * $(CORES))))

# Terminal color and modifier attributes. Make sure to handle when no terminal
# is connected.
# Return to the normal terminal colors
n := $(shell tty -s && tput sgr0)
# Red color
r := $(shell tty -s && tput setaf 1)
# Green color
g := $(shell tty -s && tput setaf 2)
# Bold text
b := $(shell tty -s && tput bold)
# Underlined text
u := $(shell tty -s && tput smul)

# These targets don't correspond to actual generated files
.PHONY: default all clean veryclean check-test-defined

# By default, display the help message for the Makefile
default all: help

# Clean up most of the intermediate files generated by compilation
clean: assemble-clean build-clean sim-clean
	@rm -rf $(OUTPUT)
	@rm -rf $(OUTPUT_BASE_DIR)

# Clean up all the intermediate files generated by compilation
veryclean: clean assemble-veryclean build-veryclean sim-veryclean

# Create the specified output directory, if it doesn't exist
$(OUTPUT):
	@mkdir -p $@

# Check that the TEST variable was specified by the user
check-test-defined:
ifeq ($(strip $(TEST)),)
	@printf "$rError: Variable $bTEST$n$r was not specified.\n$n"
	@exit 1
endif

################################################################################
# Assemble Test Programs
################################################################################

# These targets don't correspond to actual files
.PHONY: assemble assemble-clean assemble-veryclean assemble-check-compiler \
	assemble-check-test assemble-check-extension assemble-check-objcopy \
	assemble-check-objdump

# The name of the entry point for assembly tests, which matches the typical main
TEST_ENTRY_POINT = main

# The runtime environment directory, which has the startup file for C programs
# and the linker script used to layout the test programs.
# TODO may need to change linker script
RUNTIME_DIR = runtime
X86_STARTUP_FILE = $(RUNTIME_DIR)/crt0.S
X86_LINKER_SCRIPT = $(RUNTIME_DIR)/test_program.ld

# The compiler for test programs, and its flags. Even though integer
# multiplication and floating point instructions aren't supported by the
# processor, we can use libgcc's software implementation of these instructions.
X86_CC = gcc
X86_CFLAGS = -static -nostdlib -nostartfiles -Wall \
	-Wextra -std=c11 -pedantic -g -Werror=implicit-function-declaration
X86_AS_LDFLAGS = -Wl,-e$(TEST_ENTRY_POINT)
X86_LDFLAGS = -Wl,-T$(X86_LINKER_SCRIPT) -lgcc

# If a C is being compiled, do so at the highest optimization level.
ifeq ($(dir $(TEST)),benchmarks/)
    X86_CFLAGS += -O3 -fno-inline
endif

# The objcopy utility for ELF files, along with its flags.
X86_OBJCOPY = objcopy
X86_OBJCOPY_FLAGS = -O binary

# The objdump utility for ELF files, along with its flags
X86_OBJDUMP = objdump
X86_OBJDUMP_FLAGS = -d -M numeric,no-aliases $(addprefix -j ,.text .ktext \
		.data .bss .kdata .kbss)

# The file extensions for all files generated, including intermediate ones
ELF_EXTENSION = elf
BINARY_EXTENSION = bin
DISAS_EXTENSION = disassembly.s

# The binary files generated when the program is assembled. There's one for each
# assembled segment: user and kernel text and data sections.
TEST_NAME = $(basename $(TEST))
BIN_SECTIONS = $(addsuffix .$(BINARY_EXTENSION),text data ktext kdata)
TEST_BIN = $(addprefix $(TEST_NAME).,$(BIN_SECTIONS))

# The name of the binary files in the output directory, used by the testbench
OUTPUT_NAME = $(OUTPUT)/mem
TEST_OUTPUT_BIN = $(addprefix $(OUTPUT_NAME).,$(BIN_SECTIONS))

# The ELF and disassembly files generated when the test is assembled
TEST_EXECUTABLE = $(addsuffix .$(ELF_EXTENSION), $(TEST_NAME))
TEST_DISASSEMBLY = $(addsuffix .$(DISAS_EXTENSION), $(TEST_NAME))

# Log file for capturing the output of assembling the test
ASSEMBLE_LOG = $(OUTPUT)/assemble.log

# Always re-run the recipe for copying binary files to the output directory,
# because the specified test can change based on the user's input.
.PHONY: $(TEST_OUTPUT_BIN)

# Prevent make from automatically deleting the intermediate ELF file generated.
# Instead, this is done manually, which prevents the commands from being echoed.
.PRECIOUS: %.$(ELF_EXTENSION)

# User-facing target to assemble the specified test
assemble: $(TEST) $(TEST_OUTPUT_BIN) $(TEST_DISASSEMBLY) | check-test-defined \
		assemble-check-extension

# Copy an assembled ASCII binary file for a section to the output directory
$(TEST_OUTPUT_BIN): $(OUTPUT_NAME).%.$(BINARY_EXTENSION): \
		$(TEST_NAME).%.$(BINARY_EXTENSION) | $(OUTPUT)
	@cp $^ $@

# Extract the given section from the program ELF file, generating a binary
$(TEST_NAME).%.$(BINARY_EXTENSION): $(TEST_EXECUTABLE) | $(OUTPUT) \
		assemble-check-objcopy check-test-defined
	@$(X86_OBJCOPY) $(X86_OBJCOPY_FLAGS) -j .$* $^ $@ |& \
			tee -a $(ASSEMBLE_LOG)

# The user data section must be handled specially when extracting it from the
# ELF file, because the .bss section is also extracted and concatenated with it.
$(TEST_NAME).data.$(BINARY_EXTENSION): $(TEST_EXECUTABLE) | \
		assemble-check-objcopy
	@$(X86_OBJCOPY) $(X86_OBJCOPY_FLAGS) -j .data -j .bss \
			--set-section-flags .bss=alloc,load,contents $^ $@

# The kernel data section must also be handled specially for the same reason
$(TEST_NAME).kdata.$(BINARY_EXTENSION): $(TEST_EXECUTABLE) | \
		assemble-check-objcopy
	@$(X86_OBJCOPY) $(X86_OBJCOPY_FLAGS) -j .kdata -j .kbss \
			--set-section-flags .kbss=alloc,load,contents $^ $@

# Generate a disassembly of the compiled program for debugging proposes
%.$(DISAS_EXTENSION): %.$(ELF_EXTENSION) | $(OUTPUT) assemble-check-objdump
	@$(X86_OBJDUMP) $(X86_OBJDUMP_FLAGS) $^ > $@ |& tee -a $(ASSEMBLE_LOG)
	@printf "\nAssembly of the test has completed. The assembly log can be "
	@printf "found at $u$(ASSEMBLE_LOG)$n.\n"
	@printf "A disassembly of the test can be found at "
	@printf "$u$*.$(DISAS_EXTENSION)$n.\n"

# Compile the assembly test program with a *.S extension to create an ELF file
%.$(ELF_EXTENSION): %.S $(X86_LINKER_SCRIPT) | $(OUTPUT) \
		assemble-check-compiler assemble-check-test
	@printf "Assembling test $u$<$n into binary files...\n"
	@$(X86_CC) $(X86_CFLAGS) $^ $(X86_LDFLAGS) $(X86_AS_LDFLAGS) -o $@ \
			|& tee $(ASSEMBLE_LOG)

# Compile the C test program with the startup file to create an ELF file
%.$(ELF_EXTENSION): $(X86_STARTUP_FILE) %.c $(X86_LINKER_SCRIPT) | \
		$(OUTPUT) assemble-check-compiler assemble-check-test
	@printf "Assembling test $u$(word 2,$^)$n into binary files...\n"
	@$(X86_CC) $(X86_CFLAGS) $(wordlist 1,2,$^) $(X86_LDFLAGS) -o $@ |& \
			tee $(ASSEMBLE_LOG)

# Checks that the given test exists. This is used when the test doesn't have
# a known extension, and suppresses the 'no rule to make...' error message
$(TEST): | assemble-check-extension assemble-check-test

# Clean up the binary files in the output directory
assemble-clean:
	@printf "Cleaning up assembled binary files in $u$(OUTPUT)$n...\n"
	@rm -f $(TEST_OUTPUT_BIN) $(ASSEMBLE_LOG)

# Clean up all the binary files in the output and project directories
assemble-veryclean: assemble-clean
	@printf "Cleaning up assembled binary files in the project directory...\n"
	@rm -f $$(find -L -name '*.$(BINARY_EXTENSION)' \
			-o -name '*.$(ELF_EXTENSION)' -o -name '*.$(DISAS_EXTENSION)')

# Check that the RISC-V compiler exists
assemble-check-compiler:
ifeq ($(shell which $(X86_CC) 2> /dev/null),)
	@printf "$rError: $u$(X86_CC)$n$r: RISC-V compiler was not found in "
	@printf "your PATH.$n\n"
	@exit 1
endif

# Check that the specified test file exists
assemble-check-test:
ifeq ($(wildcard $(TEST)),)
	@printf "$rError: $u$(TEST)$n$r: RISC-V test file does not exist.$n\n"
	@exit 1
endif

# Check that the specified test file exists
assemble-check-extension:
ifeq ($(filter %.c %.S,$(TEST)),)
	@printf "$rError: $u$(TEST)$n$r: RISC-V test file does not have a .c or .S "
	@printf "extension.$n\n"
	@exit 1
endif

# Check that the RISC-V objcopy binary utility exists
assemble-check-objcopy:
ifeq ($(shell which $(X86_OBJCOPY) 2> /dev/null),)
	@printf "$rError: $u$(X86_OBJCOPY)$n$r: RISC-V objcopy binary utility "
	@printf "was not found in your PATH.$n\n"
	@exit 1
endif

# Check that the RISC-V objdump binary utility exists
assemble-check-objdump:
ifeq ($(shell which $(X86_OBJDUMP) 2> /dev/null),)
	@printf "$rError: $u$(X86_OBJDUMP)$n$r: RISC-V objdump binary utility "
	@printf "was not found in your PATH.$n\n"
	@exit 1
endif

################################################################################
# Compile the Simulator
################################################################################

# These targets don't correspond to actual files.
.PHONY: build build-clean build-veryclean build-check-compiler

# The code files and directories created by the student. Keep the paths as
# relative for the help message. Sort the files so that the ordering is
# consistent. This is important for compilation, as the order of compilation
# affects whether or not errors are thrown by missing `include directives.
help: SRC_DIR = src
SRC_DIR := $(shell readlink -m src)
SRC = $(shell find -L $(SRC_DIR) -type f -name '*.vhd' | sort)
SRC_SUBDIRS = $(shell find -L $(SRC_DIR) -type d | sort)

# Compiler for simulation, along with its flags
SIM_CC = ghdl
SIM_CFLAGS = --std=08

# The names of log for compilation and the executable generated for simulation.
SIM_COMPILE_LOG = compilation.log
SIM_EXECUTABLE = ia32_core

# The user-facing target to compile the processor simulator into an executable.
build: $(OUTPUT)/$(SIM_EXECUTABLE)

# Compile the processor into a simulator executable. This target only depends on
# the output directory existing, so don't force it to re-run because of it.
$(OUTPUT)/$(SIM_EXECUTABLE): $(SRC) | $(OUTPUT) build-check-compiler
	@printf "Compiling design into a simulator in $u$(OUTPUT)$n...\n"
# ghdl -c [options] <files> -e <unit>
# TODO -m may be a better option
	@cd $(OUTPUT) && $(SIM_CC) -c $(SIM_CFLAGS) -o $(SIM_EXECUTABLE) \
		$(filter %.vhd,$^) -e $(TOP_UNIT) |& tee $(SIM_COMPILE_LOG)
	@printf "\nCompilation of the simulator has completed. The compilation log "
	@printf "can be found at $u$(OUTPUT)/$(SIM_COMPILE_LOG)$n\n"
	@printf "The simulator executable can be found at $u$@$n.\n"

# Clean up any files generated by compiling the simulator.
build-clean:
	@printf "Cleaning up the simulator executable...\n"
	@rm -rf $(OUTPUT)/$(SIM_EXECUTABLE) $(OUTPUT)/*.o

# Very clean is the same as clean for the build targets.
build-veryclean: build-clean

# Check that the VHDL simulator compiler exists
build-check-compiler:
ifeq ($(shell which $(SIM_CC) 2> /dev/null),)
	@printf "$rError: $u$(SIM_CC)$n$r: VHDL simulator compiler was not "
	@printf "found in your $bPATH$n$r.\n$n"
	@exit 1
endif

################################################################################
# Simulate Verilog
################################################################################

# These targets don't correspond to actual files
.PHONY: sim

# The register dump and log files generator by running the processor simulator.
SIM_REGDUMP = $(OUTPUT)/simulation.reg
SIM_LOG = simulation.log

# Always run the simulator to generate the register dump, because the specified
# test can change based on the user's input.
.PHONY: $(SIM_REGDUMP)

# User-facing target to run the simulator with the given test
sim: $(SIM_REGDUMP) | assemble check-test-defined

# Open the waveform viewer for the processor simulation with the given test.
# Wait until the simulator GUI starts up before finishing.
sim-gui: $(TEST) $(TEST_OUTPUT_BIN) $(OUTPUT)/$(SIM_EXECUTABLE) | assemble \
		check-test-defined
	@printf "Starting up the simulator gui in $u$(OUTPUT)$n...\n"
	@cd $(OUTPUT) && ./$(SIM_EXECUTABLE) -gui &
	@sleep 2

# Run the processor simulation with the given test, generating a register dump
$(SIM_REGDUMP): $(TEST) $(TEST_OUTPUT_BIN) $(OUTPUT)/$(SIM_EXECUTABLE) | \
		$(OUTPUT) assemble
	@printf "Simulating test $u$(TEST)$n in $u$(OUTPUT)$n...\n"
	@cd $(OUTPUT) && ./$(SIM_EXECUTABLE) |& tee $(SIM_LOG)
	@printf "\nSimulation has completed. The simulation log can be found at "
	@printf "$u$(OUTPUT)/$(SIM_LOG)$n\n"
	@printf "The simulator register dump can be found at $u$(SIM_REGDUMP)$n\n"

# Suppresses 'no rule to make...' error when the REF_REGDUMP doesn't exist
$(REF_REGDUMP):

# Run the reference simulator with the specified test
REFSIM_EXECUTABLE = /afs/ece/class/ece447/bin/riscv-ref-sim

refsim: $(REFSIM_EXECUTABLE) $(TEST) | assemble check-test-defined
	@printf "Running reference sim on test $u$(TEST)$n...\n"
	@$(REFSIM_EXECUTABLE) $(TEST)

# Run the reference simulator with the specified test and generate the reference regdump
REFSIM_REGDUMP = refdump.reg

refdump: $(TEST_BIN) $(REFSIM_EXECUTABLE) $(TEST) | assemble
	@printf "Generating refdump.reg from reference sim on test $u$(TEST)$n...\n"
	@printf "go\nrdump $(REFSIM_REGDUMP)\n" | $(REFSIM_EXECUTABLE) $(TEST)


# Clean up all the files generated by VCS compilation and the DVE GUI
sim-clean:
	@printf "Cleaning up simulation files...\n"
	@rm -rf $(SIM_REGDUMP) $(SIM_EXTRA_FILES) $(REFSIM_REGDUMP)

# Very clean is the same as clean for simulation
sim-veryclean: sim-clean

################################################################################
# Verify Verilog Simulation
################################################################################

# The script used to verify, and the options for it
VERIFY_SCRIPT = sdiff
VERIFY_OPTIONS = --ignore-all-space --ignore-blank-lines

# The reference register dump used to verify the simulator's
REF_REGDUMP = $(basename $(TEST)).reg

# Based on the lab number being targeted, select that the tests that the
# students are required to pass for checkoff. Some labs do not require control
# flow instructions, so those tests are skipped.

# Basic test set
PUBLIC_TESTS = $(addprefix 447inputs/,additest.S addtest.S arithtest.S \
		 memtest0.S memtest1.S shifttest.S syscalltest.S)

# Dependence stress test
ifneq ($(filter $(LAB_18447),2 3 4a 4b),)
    PUBLIC_TESTS += $(addprefix 447inputs/,dependLow.S depend.S )
endif

# Control flow test
ifneq ($(filter $(LAB_18447),1b 3 4b),)
    PUBLIC_TESTS += $(addprefix 447inputs/,brtest0.S brtest1.S brtest2.S)
endif

# C tests
ifneq ($(filter $(LAB_18447),3 4b),)
    PUBLIC_TESTS += $(addprefix benchmarks/,fibi.c fibm.c fibr.c)
endif

# multiply tests
ifneq ($(filter $(LAB_18447),4a 4b),)
    PUBLIC_TESTS += $(addprefix 447inputs/, multest.S dependMulLow.S dependMul.S)
endif

# lab4b specials
ifneq ($(filter $(LAB_18447),4b),)
    PUBLIC_TESTS += $(addprefix benchmarks/, mixed.c mmmRV32IM.c)
endif

# The autograde tests default to the public tests, if none were specified.
ifeq ($(strip $(TESTS)),)
    TESTS = $(PUBLIC_TESTS)
endif

# These targets don't correspond to actual generated files
.PHONY: verify autograde verify-check-ref-regdump

# Verify that the processor simulator's register dump for the given test matches
# the reference register dump, in the corresponding *.reg file
verify: $(SIM_REGDUMP) $(REF_REGDUMP) | assemble verify-check-ref-regdump \
		check-test-defined
	@printf "\n"
	@if $(VERIFY_SCRIPT) $(VERIFY_OPTIONS) $^ &> /dev/null; then \
		printf "$gCorrect! The simulator register dump matches the "; \
		printf "reference.$n\n"; \
	else \
		printf "\n%-67s\t%s\n\n" "$u$(SIM_REGDUMP)$n" "$u$(REF_REGDUMP)$n"; \
		$(VERIFY_SCRIPT) $(VERIFY_OPTIONS) $^; \
		printf "$rIncorrect! The simulator register dump does not match the "; \
		printf "reference.$n\n"; \
		exit 1; \
	fi

# Run verification on the specified series of tests. If left unspecified, then
# this defaults to the public tests students are required to pass for this lab.
autograde:
	@printf "%-30s %s\n" "Test" "Result"
	@printf "%.0s-" {1..37}
	@printf "\n"
	@for test in $(TESTS); do \
		printf "$b%-26s %s$n" "$${test}" "Running..."; \
		make verify TEST=$${test} OUTPUT=$(OUTPUT) &> /dev/null; \
		if [ $$? -eq 0 ]; then \
			printf "\r$g%-30s %s$n\n" "$${test}" "Passed"; \
		else \
			printf "\r$r%-30s %s$n\n" "$${test}" "Failed"; \
		fi \
	done

# Suppresses 'no rule to make...' error when the REF_REGDUMP doesn't exist
$(REF_REGDUMP):

# Check that the reference register dump for the specified test exists
verify-check-ref-regdump:
ifeq ($(wildcard $(REF_REGDUMP)),)
	@printf "$rError: $u$(REF_REGDUMP)$n$r: Reference register dump for test "
	@printf "$u$(TEST)$n$r does not exist.\n$n"
	@exit 1
endif

################################################################################
# Help Target
################################################################################

# These targets don't correspond to actual generated files
.PHONY: help

# Display a help message about how to use the Makefile to the user
help:
	@printf "TODO\n"
